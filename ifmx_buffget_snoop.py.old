#!/usr/bin/python3
#
# buffget_snoop  Trace buffget() library function for a given PID.
#               For Linux, uses BCC, eBPF. Embedded C.
#
# USAGE: buffgetsnoop 
# ./buffget_snoop.py 
#TIME(s)            COMM             PID    PHYSADDR
#35730.223070000    b'oninit'        2714   b'9:20'
#35730.223138000    b'oninit'        2714   b'9:8'
#35730.223152000    b'oninit'        2714   b'9:8'
#35730.223183000    b'oninit'        2714   b'9:1140'
#35730.223195000    b'oninit'        2714   b'9:8'
#35730.223213000    b'oninit'        2714   b'9:1136'
#35730.223234000    b'oninit'        2714   b'9:8'
#35730.223252000    b'oninit'        2714   b'9:1132'

from __future__ import print_function
from bcc import BPF
from os import getpid
import sys
import os

#
#if len(sys.argv) < 2:
#    print("USAGE: buffgetsnoop PID")
#    exit()
pid = 0
#pid = sys.argv[1]

# load BPF program
bpf_text = """
#include <uapi/linux/ptrace.h>

typedef struct ifx_physaddr {
    u32 pg_offset;            
    u32 pg_chunk;
} ifx_physaddr_t;

int printarg(struct pt_regs *ctx) {
    if (!PT_REGS_PARM2(ctx))
        return 0;

    u32 pid = bpf_get_current_pid_tgid();
/*
    if (pid != PID)
        return 0;
*/

    ifx_physaddr_t  physaddr = {0};
    u64 paddr = PT_REGS_PARM2(ctx);
     if (!paddr)
         return 0;
    physaddr.pg_offset = (int)paddr;
    physaddr.pg_chunk = (int)(paddr>>32);
    bpf_trace_printk("%d:%d\\n", physaddr.pg_chunk, physaddr.pg_offset);

    return 0;
};
"""
#bpf_text = bpf_text.replace('PID', pid)
b = BPF(text=bpf_text)
oninitpath=str(os.environ.get('INFORMIXDIR'))+"/bin/oninit"
b.attach_uprobe(name=oninitpath, sym="buffget", fn_name="printarg")

# header
print("%-18s %-16s %-6s %s" % ("TIME(s)", "COMM", "PID", "PHYSADDR"))

# format output
me = getpid()
while 1:
    try:
        (task, pid, cpu, flags, ts, msg) = b.trace_fields()
    except ValueError:
        continue
    if pid == me or msg == "":
        continue
    print("%-18.9f %-16s %-6d %s" % (ts, task, pid, msg))
